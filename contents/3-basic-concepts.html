<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>3.基本概念</title>
    <link rel="stylesheet" type="text/css" href="style.css" />
  </head>
  <body>
    <h1>基本概念</h1>
    
    <h2>变量,语法关键词,和作用域</h2>
    <div>
      <p>一个标示符可以命名一种<em>语法形式</em>,或者一个<em>储存值的位置</em>.前者被称作<em>语法关键词</em>,我们说,<em>它被绑定到该语法的转换器</em>(transformer for that syntax).后者被称为<em>变量</em>,我们说,<em>它被绑定到那个地址</em>.在程序的某个位置起作用的所有绑定构成的集合,被认定是那个执行位置的<em>环境</em>(environment).储存在某个变量绑定的位置的值,被称作该<em>变量的值</em>.但由于术语的滥用,我们常常说这个这个变量是该值的"名字",或是该变量被绑定到了该值上.这种说法并不十分准确,但很少引起误解(,所以不妨沿用这种说法).</p>
      <p>一些表达式类型被用来构造新的语法和绑定这些语法到语法关键词上;同时还有一些别的表达式可以创造新的储存空间并绑定变量到这些位置上.这些表达式统称为<em>绑定构造</em>(binding constructs).能绑定语法关键词的绑定构造列举在4.3章节中.最重要的变量绑定构造是lambda表达式,因为所有其余的变量绑定构造都可以转化为lambda表达式的形式. 其他变量绑定构造有<span>let,let*,letrec,letrec*,let-values,let*-values,和 do</span> 表达式(参见4.1.4,4.2.2,和4.2.4).</p>
      <p>Scheme支持块结构.每一次绑定标示符,都对应着一个该绑定可见的<em>作用域</em>.这个作用域由建立该绑定的绑定构造确定.例如,如果该绑定由lambda表达式建立,则该绑定的作用域是整个lambda表达式.在作用域内,每次引用标示符,都会从最内层(最靠近引用位置)的作用域开始寻找相应的绑定.如果所有作用域都没找到,就会在<em>全局环境</em>中寻找(参见4,6章);如果全局环境也不包含该标示符的绑定,我们称该标示符是<em>未绑定的</em></p>
    </div>
    
    <h2>不同的类型</h2>
    <div>
      <p>没有任何一个对象同时满足多于一个以下的<em>断言</em></p>
      <table class="code-table">
	<tr>
	  <td>boolean?</td>
	  <td>bytevector?</td>
	</tr>
	<tr>
	  <td>char?</td>
	  <td>eof-object?</td>
	</tr>
	<tr>
	  <td>null?</</td>
	  <td>number?</td>
	</tr>
	<tr>
	  <td>pair?</td>
	  <td>port?</td>
	</tr>
	<tr>
	  <td>procedure?</td>
	  <td>string?</td>
	</tr>
	<tr>
	  <td>symbol?</td>
	  <td>vector?</td>
	</tr>
      </table>
      <p>和所有由<span>define-record-type</span>创造的断言.</p>
      <p>这些断言定义了以下几种类型:<em>布尔,比特向量,字符,空表,eof对象,数字,点对,端口,过程,字符串,符号,向量,和所有记录类型</em>.</p>
      <p>虽然有独立的布尔类型,Scheme中所有的值都可以在条件语法结构中的判断句中被当成布尔值来使用.正如6.3中所说,除了<span>#f</span>,所有值都会在判断中被当成真.这个报告用"真"来指代任何除了<span>#f</span>以外的Scheme值,用"假"来指代<span>#f</span>.
    </div>
    
    <h2>外部表示</h2>
    <div>
    <p>在Scheme(和其他Lisp)中有一个很重要的概念,就是对象的<em>外部标示</em>例如,数字28的外部标示是字符序列"28",包含整数8和13的表的外部表示是"(8 13)".</p>
    <p>对象的外部表示不一定是唯一的,整数28的外部表示也可以是"#e28.000"和"#x1c",而刚示例中的表,也可以有以下外部表示:"( 08 13 )"和"(8 . (13 . ()))"(参见6.4章).</p>
    <p>很多对象有标准的外部表示,但有一些对象,例如过程,并没有标准的外部表示(虽然某些实现会给它们定义相应的外部表示).</p>
    <p>人们可以在程序中书写外部表示以获得相应的对象(参见<span>quote</span>,4.1.2章).</p>
    <p>外部表示也可以被用作输入和输出.过程<span>read</span>(参见6.13.2)解析外部表示,而过程<span>write</span>(参见6.13.3)能生成外部表示.它们共同提供了优雅而强大的i/o特性.</p>
    <p>需要注意的是,字符序列"(+ 2 6)"并<em>不是</em>数字8的外部表示,即便它<em>是</em>一个求值结果为8的表达式;然而,它是一个三元素表的外部表示,这些元素是符号<span>+</span>和整数<span>2</span>和<span>6</span>.Scheme的语法具有一个特点:任何表达式都是某些对象的外部表示.这个也许会引起思维上的混乱,因为它让我们有时会分不清一串字符到底是数据还是程序,但这也是一个魔力的源泉,因为它有助于写出需要把程序当数据处理的程序,例如解释器和编译器(反之亦然).</p>
    <p>更多关于外部表示的语法和操作,请参阅第6章.</div>
    
    <h2>储存机制模型</h2>
    <div>
      <p>变量和对象例如点对,字符串,向量,和比特向量指示着储存位置和位置序列.例如,一个字符串,指示了和它包含的字符一样多的储存位置.一个新的值可以用<span>string-set!</span>储存进这些位置,但字符串指示的位置序列并不会改变.</p>
      <p>一个对象对应一个储存位置.可以通过</div>
    
    <h2>恰当的尾递归</h2>
    <div></div>
  </body>
</html>
